package rars;

import rars.assembler.SymbolTable;
import rars.assembler.Token;
import rars.assembler.TokenList;
import rars.assembler.TokenType;
import rars.riscv.BasicInstruction;
import rars.riscv.BasicInstructionFormat;
import rars.riscv.Instruction;
import rars.riscv.Instructions;
import rars.riscv.hardware.ControlAndStatusRegisterFile;
import rars.riscv.hardware.FloatingPointRegisterFile;
import rars.riscv.hardware.Register;
import rars.riscv.hardware.RegisterFile;
import rars.settings.BoolSetting;
import rars.util.Binary;
import rars.venus.NumberDisplayBaseChooser;

import java.util.ArrayList;

import static rars.settings.Settings.boolSettings;


/*
Copyright (c) 2003-2013,  Pete Sanderson and Kenneth Vollmar

Developed by Pete Sanderson (psanderson@otterbein.edu)
and Kenneth Vollmar (kenvollmar@missouristate.edu)

Permission is hereby granted, free of charge, to any person obtaining 
a copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject 
to the following conditions:

The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(MIT license, http://www.opensource.org/licenses/mit-license.html)
 */

/**
 * Represents one assembly/machine statement. This represents the "bare machine"
 * level.
 * Pseudo-instructions have already been processed at this point and each
 * assembly
 * statement generated by them is one of these.
 *
 * @author Pete Sanderson and Jason Bumgarner
 * @version August 2003
 */
public final class ProgramStatement implements Comparable<ProgramStatement> {
    private static final String invalidOperator = "<INVALID>";
    private final RISCVprogram sourceProgram;
    private final TokenList originalTokenList;
    private final TokenList strippedTokenList;
    private final BasicStatementList basicStatementList;
    private final int[] operands;
    private final Instruction instruction;
    private final int textAddress;
    private final boolean altered;
    private String source, basicAssemblyStatement, machineStatement;
    private int numOperands;
    private int sourceLine;
    private int binaryStatement;

    //////////////////////////////////////////////////////////////////////////////////

    /**
     * Constructor for ProgramStatement when there are links back to all source and
     * token
     * information. These can be used by a debugger later on.
     *
     * @param sourceProgram     The RISCVprogram object that contains this statement
     * @param source            The corresponding RISCV source statement.
     * @param origTokenList     Complete list of Token objects (includes labels,
     *                          comments, parentheses, etc)
     * @param strippedTokenList List of Token objects with all but operators and
     *                          operands removed.
     * @param inst              The Instruction object for this statement's
     *                          operator.
     * @param textAddress       The Text Segment address in memory where the binary
     *                          machine code for this statement
     *                          is stored.
     * @param sourceLine        a int
     */
    public ProgramStatement(final RISCVprogram sourceProgram, final String source, final TokenList origTokenList,
                            final TokenList strippedTokenList,
                            final Instruction inst, final int textAddress, final int sourceLine) {
        this.sourceProgram = sourceProgram;
        this.source = source;
        this.originalTokenList = origTokenList;
        this.strippedTokenList = strippedTokenList;
        this.operands = new int[5];
        this.numOperands = 0;
        this.instruction = inst;
        this.textAddress = textAddress;
        this.sourceLine = sourceLine;
        this.basicAssemblyStatement = null;
        this.basicStatementList = new BasicStatementList();
        this.machineStatement = null;
        this.binaryStatement = 0; // nop, or sll $0, $0, 0 (32 bits of 0's)
        this.altered = false;
    }

    //////////////////////////////////////////////////////////////////////////////////

    /**
     * Constructor for ProgramStatement used only for writing a binary machine
     * instruction with no source code to refer back to. Originally supported
     * only NOP instruction (all zeroes), but extended in release 4.4 to support
     * all basic instructions. This was required for the self-modifying code
     * feature.
     *
     * @param binaryStatement The 32-bit machine code.
     * @param textAddress     The Text Segment address in memory where the binary
     *                        machine code for this statement
     *                        is stored.
     */
    public ProgramStatement(final int binaryStatement, final int textAddress) {
        this.sourceProgram = null;
        this.binaryStatement = binaryStatement;
        this.textAddress = textAddress;
        this.originalTokenList = this.strippedTokenList = null;
        this.source = "";
        this.machineStatement = this.basicAssemblyStatement = null;
        final var instr = Instructions.findBasicInstructionByBinaryCode(binaryStatement);
        if (instr == null) {
            this.operands = null;
            this.numOperands = 0;
            this.instruction = null;
        } else {
            this.operands = new int[5];
            this.numOperands = 0;
            this.instruction = instr;
            final String mask = instr.getOperationMask();
            final BasicInstructionFormat format = instr.getInstructionFormat();
            if (format == BasicInstructionFormat.J_FORMAT) {
                this.operands[0] = ProgramStatement.readBinaryCode(mask, Instruction.operandMask[0], binaryStatement);
                this.operands[1] = ProgramStatement.fromJumpImmediate(
                        ProgramStatement.readBinaryCode(mask, Instruction.operandMask[1], binaryStatement));
                this.numOperands = 2;
            } else if (format == BasicInstructionFormat.B_FORMAT) {
                this.operands[0] = ProgramStatement.readBinaryCode(mask, Instruction.operandMask[0], binaryStatement);
                this.operands[1] = ProgramStatement.readBinaryCode(mask, Instruction.operandMask[1], binaryStatement);
                this.operands[2] = ProgramStatement.fromBranchImmediate(
                        ProgramStatement.readBinaryCode(mask, Instruction.operandMask[2], binaryStatement));
                this.numOperands = 3;
            } else { // Everything else is normal
                for (int i = 0; i < 5; i++) {
                    if (mask.indexOf(Instruction.operandMask[i]) != -1) {
                        this.operands[i] = ProgramStatement.readBinaryCode(mask, Instruction.operandMask[i],
                                binaryStatement);
                        this.numOperands++;
                    }
                }
            }
        }
        this.altered = false;
        this.basicStatementList = ProgramStatement.buildBasicStatementListFromBinaryCode(binaryStatement, instr,
                this.operands, this.numOperands);
    }

    private static int toJumpImmediate(int address) {
        // trying to produce immediate[20:1] where immediate = address[20|10:1|11|19:12]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 19)) | // keep the top bit in the same place
                ((address & 0x3FF) << 9) | // move address[10:1] to the right place
                ((address & (1 << 10)) >> 2) | // move address[11] to the right place
                ((address & 0x7F800) >> 11); // move address[19:12] to the right place
    }

    /// //////////////////////////////////////////////////////////////////////////

    private static int fromJumpImmediate(final int immediate) {
        // trying to produce address[20:0] where immediate = address[20|10:1|11|19:12]
        final int tmp = ((immediate) & (1 << 19)) | // keep the top bit in the same place
                ((immediate & 0x7FE00) >> 9) | // move address[10:1] to the right place
                ((immediate & (1 << 8)) << 2) | // move address[11] to the right place
                ((immediate & 0xFF) << 11); // move address[19:12] to the right place
        return (tmp << 12) >> 11; // sign-extend and add extra 0
    }

    /// //////////////////////////////////////////////////////////////////////////

    private static int toBranchImmediate(int address) {
        // trying to produce imm[12:1] where immediate = address[12|10:1|11]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 11)) | // keep the top bit in the same place
                ((address & 0x3FF) << 1) | // move address[10:1] to the right place
                ((address & (1 << 10)) >> 10); // move address[11] to the right place
    }

    private static int fromBranchImmediate(final int immediate) {
        // trying to produce address[12:0] where immediate = address[12|10:1|11]
        final int tmp = (immediate & (1 << 11)) | // keep the top bit in the same place
                ((immediate & 0x7FE) >> 1) | // move address[10:1] to the right place
                ((immediate & 1) << 10); // move address[11] to the right place
        return (tmp << 20) >> 19; // sign-extend and add extra 0
    }

    /**
     * Reads an operand from a binary statement according to a mask and format
     * <p>
     * i.e.
     *
     * <pre>
     * 0b01001 == readBinaryCode("ttttttttttttttsssss010fffff1101001", 'f',
     *         0b0101000001000001000010010011101001)
     * </pre>
     *
     * @param format          the format of the full binary statement (all operands
     *                        present)
     * @param mask            the second (f,s, or t) to mask out
     * @param binaryStatement the binary statement to read from
     * @return the bits read pushed to the right
     */
    private static int readBinaryCode(final String format, final char mask, final int binaryStatement) {
        int out = 0;
        for (int i = 0; i < 32; i++) {
            if (format.charAt(i) == mask) {
                // if the mask says to read, shift the output left and add substitute bit i
                out = (out << 1) | ((binaryStatement >> (31 - i)) & 1);
            }
        }
        return out;
    }

    /// ///////////////////////////////////////////////////////////////////////////
    /*
     * Given a model BasicInstruction and the assembled (not source) operand array
     * for a statement,
     * this method will construct the corresponding basic instruction list. This
     * method is
     * used by the constructor that is given only the int address and binary code.
     * It is not
     * intended to be used when source code is available. DPS 11-July-2013
     */
    private static BasicStatementList buildBasicStatementListFromBinaryCode(final int binary,
                                                                            final BasicInstruction instr,
                                                                            final int[] operands,
                                                                            final int numOperands) {
        final BasicStatementList statementList = new BasicStatementList();
        int tokenListCounter = 1; // index 0 is operator; operands start at index 1
        if (instr == null) {
            statementList.addString(ProgramStatement.invalidOperator);
            return statementList;
        } else {
            statementList.addString(instr.getName() + " ");
        }
        final var tokenList = Instructions.getTokenList(instr);
        for (int i = 0; i < numOperands; i++) {
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if (tokenListCounter > 1 && tokenListCounter < tokenList.size()) {
                final TokenType thisTokenType = tokenList.get(tokenListCounter).getType();
                if (thisTokenType != TokenType.LEFT_PAREN && thisTokenType != TokenType.RIGHT_PAREN) {
                    statementList.addString(",");
                }
            }
            boolean notOperand = true;
            while (notOperand && tokenListCounter < tokenList.size()) {
                final TokenType tokenType = tokenList.get(tokenListCounter).getType();
                if (tokenType.equals(TokenType.LEFT_PAREN)) {
                    statementList.addString("(");
                } else if (tokenType.equals(TokenType.RIGHT_PAREN)) {
                    statementList.addString(")");
                } else if (tokenType.toString().contains("REGISTER")) {
                    final String marker = (tokenType.toString().contains("FP_REGISTER")) ? "f" : "x";
                    statementList.addString(marker + operands[i]);
                    notOperand = false;
                } else if (tokenType.equals(TokenType.INTEGER_12)) {
                    statementList.addValue((operands[i] << 20) >> 20);
                    notOperand = false;
                } else if (tokenType.equals(TokenType.ROUNDING_MODE)) {
                    final String[] modes = new String[]{"rne", "rtz", "rdn", "rup", "rmm", "invalid", "invalid", "dyn"};
                    String value = "invalid";
                    if (operands[i] >= 0 && operands[i] < 8) {
                        value = modes[operands[i]];
                    }
                    statementList.addString(value);
                    notOperand = false;
                } else {
                    statementList.addValue(operands[i]);
                    notOperand = false;
                }
                tokenListCounter++;
            }
        }
        while (tokenListCounter < tokenList.size()) {
            final TokenType tokenType = tokenList.get(tokenListCounter).getType();
            if (tokenType.equals(TokenType.LEFT_PAREN)) {
                statementList.addString("(");
            } else if (tokenType.equals(TokenType.RIGHT_PAREN)) {
                statementList.addString(")");
            }
            tokenListCounter++;
        }
        return statementList;
    } // buildBasicStatementListFromBinaryCode()

    /**
     * <p>compareTo.</p>
     *
     * @param obj1 a {@link ProgramStatement} object
     * @return a int
     */
    @Override
    public int compareTo(final ProgramStatement obj1) {
        final int addr1 = this.getAddress();
        final int addr2 = obj1.getAddress();
        return (addr1 < 0 && addr2 >= 0 || addr1 >= 0 && addr2 < 0) ? addr2 : addr1 - addr2;
    }

    /**
     * Given specification of BasicInstruction for this operator, build the
     * corresponding assembly statement in basic assembly format (e.g. substituting
     * register numbers for register names, replacing labels by values).
     *
     * @param errors The list of assembly errors encountered so far. May add to it
     *               here.
     */
    public void buildBasicStatementFromBasicInstruction(final ErrorList errors) {
        Token token = this.strippedTokenList.get(0);
        String basicStatementElement = token.getValue() + " ";

        final StringBuilder basic = new StringBuilder(basicStatementElement);
        this.basicStatementList.addString(basicStatementElement); // the operator
        TokenType tokenType, nextTokenType;
        String tokenValue;
        int registerNumber;
        this.numOperands = 0;
        for (int i = 1; i < this.strippedTokenList.size(); i++) {
            token = this.strippedTokenList.get(i);
            tokenType = token.getType();
            tokenValue = token.getValue();
            if (tokenType == TokenType.REGISTER_NUMBER) {
                basicStatementElement = tokenValue;
                basic.append(basicStatementElement);
                this.basicStatementList.addString(basicStatementElement);
                try {
                    registerNumber = RegisterFile.getRegister(tokenValue).getNumber();
                } catch (final Exception e) {
                    // should never happen; should be caught before now...
                    errors.addTokenError(token, "invalid register name");
                    return;
                }
                this.operands[this.numOperands++] = registerNumber;
            } else if (tokenType == TokenType.REGISTER_NAME) {
                registerNumber = RegisterFile.getRegister(tokenValue).getNumber();
                basicStatementElement = "x" + registerNumber;
                basic.append(basicStatementElement);
                this.basicStatementList.addString(basicStatementElement);
                if (registerNumber < 0) {
                    // should never happen; should be caught before now...
                    errors.addTokenError(token, "invalid register name");
                    return;
                }
                this.operands[this.numOperands++] = registerNumber;
            } else if (tokenType == TokenType.CSR_NAME) {
                // Little bit of a hack because CSRFile doesn't supoprt getRegister(strinug)
                final Register[] regs = ControlAndStatusRegisterFile.getRegisters();
                registerNumber = -1;
                for (final Register r : regs) {
                    if (r.getName().equals(tokenValue)) {
                        registerNumber = r.getNumber();
                        break;
                    }
                }
                if (registerNumber < 0) {
                    // should never happen; should be caught before now...
                    errors.addTokenError(token, "invalid CSR name");
                    return;
                }
                basic.append(registerNumber);
                this.basicStatementList.addString("" + registerNumber);
                this.operands[this.numOperands++] = registerNumber;
            } else if (tokenType == TokenType.FP_REGISTER_NAME) {
                registerNumber = FloatingPointRegisterFile.getRegister(tokenValue).getNumber();
                basicStatementElement = "f" + registerNumber;
                basic.append(basicStatementElement);
                this.basicStatementList.addString(basicStatementElement);
                if (registerNumber < 0) {
                    // should never happen; should be caught before now...
                    errors.addTokenError(token, "invalid FPU register name");
                    return;
                }
                this.operands[this.numOperands++] = registerNumber;
            } else if (tokenType == TokenType.ROUNDING_MODE) {
                final int rounding_mode = switch (tokenValue) {
                    case "rne" -> 0;
                    case "rtz" -> 1;
                    case "rdn" -> 2;
                    case "rup" -> 3;
                    case "rmm" -> 4;
                    case "dyn" -> 7;
                    default -> -1;
                };
                if (rounding_mode == -1) {
                    errors.addTokenError(token, "invalid rounding mode");
                    return;
                }
                basic.append(tokenValue);
                this.basicStatementList.addString(tokenValue);
                this.operands[this.numOperands++] = rounding_mode;
            } else if (tokenType == TokenType.IDENTIFIER) {

                int address = this.sourceProgram.getLocalSymbolTable().getAddressLocalOrGlobal(tokenValue);
                if (address == SymbolTable.NOT_FOUND) { // symbol used without being defined
                    errors.addTokenError(token, "Symbol \"%s\" not found in symbol table.".formatted(tokenValue));
                    return;
                }
                boolean absoluteAddress = true; // (used below)

                if (this.instruction instanceof BasicInstruction) {
                    final BasicInstructionFormat format = ((BasicInstruction) this.instruction).getInstructionFormat();
                    if (format == BasicInstructionFormat.B_FORMAT) {
                        address -= this.textAddress;
                        if (address >= (1 << 12) || address < -(1 << 12)) {
                            // SPIM flags as warning, I'll flag as error b/c RARS text segment not long
                            // enough for it to be OK.
                            errors.add(ErrorMessage.error(this.sourceProgram, this.sourceLine, 0,
                                    "Branch target word address beyond 12-bit range"));
                            return;
                        }
                        absoluteAddress = false;
                    } else if (format == BasicInstructionFormat.J_FORMAT) {
                        address -= this.textAddress;
                        if (address >= (1 << 20) || address < -(1 << 20)) {
                            errors.add(ErrorMessage.error(this.sourceProgram, this.sourceLine, 0,
                                    "Jump target word address beyond 20-bit range"));
                            return;
                        }
                        absoluteAddress = false;
                    }
                }
                //////////////////////////////////////////////////////////////////////
                basic.append(address);
                if (absoluteAddress) { // record as address if absolute, second if relative
                    this.basicStatementList.addAddress(address);
                } else {
                    this.basicStatementList.addValue(address);
                }
                this.operands[this.numOperands++] = address;
            } else if (tokenType == TokenType.INTEGER_5 || tokenType == TokenType.INTEGER_6
                    || tokenType == TokenType.INTEGER_12 ||
                    tokenType == TokenType.INTEGER_12U || tokenType == TokenType.INTEGER_20
                    || tokenType == TokenType.INTEGER_32) {

                final int tempNumeric = Binary.stringToInt(tokenValue);

                /* **************************************************************************
                 * MODIFICATION AND COMMENT, DPS 3-July-2008
                 *
                 * The modifications of January 2005 documented below are being rescinded.
                 * All hexadecimal immediate values are considered 32 bits in length and
                 * their classification as INTEGER_5, INTEGER_16, INTEGER_16U (new)
                 * or INTEGER_32 depends on their 32 bit second. So 0xFFFF will be
                 * equivalent to 0x0000FFFF instead of 0xFFFFFFFF. This change, along with
                 * the introduction of INTEGER_16U (adopted from Greg Gibeling of Berkeley),
                 * required extensive changes to instruction templates especially for
                 * pseudo-instructions.
                 *
                 * This modification also appears inbuildBasicStatementFromBasicInstruction()
                 * in rars.ProgramStatement.
                 *
                 * ///// Begin modification 1/4/05 KENV
                 * ///////////////////////////////////////////
                 * // We have decided to interpret non-signed (no + or -) 16-bit hexadecimal
                 * immediate
                 * // operands as signed values in the range -32768 to 32767. So 0xffff will
                 * represent
                 * // -1, not 65535 (bit 15 as sign bit), 0x8000 will represent -32768 not
                 * 32768.
                 * // NOTE: 32-bit hexadecimal immediate operands whose values fall into this
                 * range
                 * // will be likewise affected, but they are used only in pseudo-instructions.
                 * The
                 * // code in ExtendedInstruction.java to split this number into upper 16 bits
                 * for "lui"
                 * // and lower 16 bits for "ori" works with the original source code token, so
                 * it is
                 * // not affected by this tweak. 32-bit immediates in data segment directives
                 * // are also processed elsewhere so are not affected either.
                 * ////////////////////////////////////////////////////////////////////////////////
                 *
                 * if (tokenType != TokenTypes.INTEGER_16U) { // part of the Berkeley mod...
                 * if ( Binary.isHex(tokenValue) &&
                 * (tempNumeric >= 32768) &&
                 * (tempNumeric <= 65535) ) // Range 0x8000 ... 0xffff
                 * {
                 * // Subtract the 0xffff bias, because strings in the
                 * // range "0x8000" ... "0xffff" are used to represent
                 * // 16-bit negative numbers, not positive numbers.
                 * tempNumeric = tempNumeric - 65536;
                 * // Note: no action needed for range 0xffff8000 ... 0xffffffff
                 * }
                 * }
                 ************************** END DPS 3-July-2008 COMMENTS
                 *******************************/

                basic.append(tempNumeric);
                if (tokenType == TokenType.INTEGER_5) {
                    this.basicStatementList.addShortValue(tempNumeric);
                } else {
                    this.basicStatementList.addValue(tempNumeric);
                }
                this.operands[this.numOperands++] = tempNumeric;
                ///// End modification 1/7/05 KENV ///////////////////////////////////////////
            } else {
                basicStatementElement = tokenValue;
                basic.append(basicStatementElement);
                this.basicStatementList.addString(basicStatementElement);
            }
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if ((i < this.strippedTokenList.size() - 1)) {
                nextTokenType = this.strippedTokenList.get(i + 1).getType();
                if (tokenType != TokenType.LEFT_PAREN && tokenType != TokenType.RIGHT_PAREN &&
                        nextTokenType != TokenType.LEFT_PAREN && nextTokenType != TokenType.RIGHT_PAREN) {
                    basicStatementElement = ",";
                    basic.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                }
            }
        }
        this.basicAssemblyStatement = basic.toString();
    } // buildBasicStatementFromBasicInstruction()

    /**
     * Given the current statement in Basic Assembly format (see above), build the
     * 32-bit binary machine code statement.
     *
     * @param errors The list of assembly errors encountered so far. May add to it
     *               here.
     */
    public void buildMachineStatementFromBasicStatement(final ErrorList errors) {
        if (!(this.instruction instanceof BasicInstruction)) {
            // This means the pseudo-instruction expansion generated another
            // pseudo-instruction (expansion must be to all basic instructions).
            // This is an error on the part of the pseudo-instruction author.
            errors.add(ErrorMessage.error(this.sourceProgram, this.sourceLine, 0,
                    "INTERNAL ERROR: pseudo-instruction expansion contained a pseudo-instruction"));
            return;
        }

        // mask indicates bit positions for 'f'irst, 's'econd, 't'hird operand
        this.machineStatement = ((BasicInstruction) this.instruction).getOperationMask();
        final BasicInstructionFormat format = ((BasicInstruction) this.instruction).getInstructionFormat();

        if (format == BasicInstructionFormat.J_FORMAT) {
            this.insertBinaryCode(this.operands[0], Instruction.operandMask[0], errors);
            this.insertBinaryCode(ProgramStatement.toJumpImmediate(this.operands[1]), Instruction.operandMask[1],
                    errors);
        } else if (format == BasicInstructionFormat.B_FORMAT) {
            this.insertBinaryCode(this.operands[0], Instruction.operandMask[0], errors);
            this.insertBinaryCode(this.operands[1], Instruction.operandMask[1], errors);
            this.insertBinaryCode(ProgramStatement.toBranchImmediate(this.operands[2]), Instruction.operandMask[2],
                    errors);
        } else { // Everything else is normal
            for (int i = 0; i < this.numOperands; i++)
                this.insertBinaryCode(this.operands[i], Instruction.operandMask[i], errors);
        }
        this.binaryStatement = Binary.binaryStringToInt(this.machineStatement);
    }

    /**
     * Crude attempt at building String representation of this complex structure.
     *
     * @return A String representing the ProgramStatement.
     */
    @Override
    public String toString() {
        // a crude attempt at string formatting. Where's C when you need it?
        final String blanks = "                               ";
        final StringBuilder result = new StringBuilder("[" + this.textAddress + "]");
        if (this.basicAssemblyStatement != null) {
            final int firstSpace = this.basicAssemblyStatement.indexOf(" ");
            result.append(blanks, 0, 16 - result.length()).append(this.basicAssemblyStatement, 0, firstSpace);
            result.append(blanks, 0, 24 - result.length()).append(this.basicAssemblyStatement.substring(firstSpace + 1));
        } else {
            result.append(blanks, 0, 16 - result.length()).append("0x").append(Integer.toString(this.binaryStatement,
                    16));
        }
        result.append(blanks, 0, 40 - result.length()).append(";  "); // this.source;
        if (this.operands != null) {
            for (int i = 0; i < this.numOperands; i++)
                // result += operands[i] + " ";
                result.append(Integer.toString(this.operands[i], 16)).append(" ");
        }
        if (this.machineStatement != null) {
            result.append("[").append(Binary.binaryStringToHexString(this.machineStatement)).append("]");
            result.append("  ").append(this.machineStatement, 0, 6).append("|").append(this.machineStatement, 6, 11).append("|").append(this.machineStatement, 11, 16).append("|").append(this.machineStatement, 16, 21).append("|").append(this.machineStatement, 21, 26).append("|").append(this.machineStatement, 26, 32);
        }
        return result.toString();
    } // toString()

    /**
     * Produces RISCVprogram object representing the source file containing this
     * statement.
     *
     * @return The RISCVprogram object. May be null...
     */
    public RISCVprogram getSourceProgram() {
        return this.sourceProgram;
    }

    /**
     * Produces String name of the source file containing this statement.
     *
     * @return The file name.
     */
    public String getSourceFile() {
        return (this.sourceProgram == null) ? "" : this.sourceProgram.getFilename();
    }

    /**
     * Produces RISCV source statement.
     *
     * @return The RISCV source statement.
     */
    public String getSource() {
        return this.source;
    }

    /**
     * associates RISCV source statement. Used by assembler when generating basic
     * statements during macro expansion of extended statement.
     *
     * @param src a RISCV source statement.
     */
    public void setSource(final String src) {
        this.source = src;
    }

    /**
     * Produces line number of RISCV source statement.
     *
     * @return The RISCV source statement line number.
     */
    public int getSourceLine() {
        return this.sourceLine;
    }

    /**
     * Produces Basic Assembly statement for this RISCV source statement.
     * All numeric values are in decimal.
     *
     * @return The Basic Assembly statement.
     */
    public String getBasicAssemblyStatement() {
        return this.basicAssemblyStatement;
    }

    /**
     * Assigns given String to be Basic Assembly statement equivalent to this source
     * line.
     *
     * @param statement A String containing equivalent Basic Assembly statement.
     */
    public void setBasicAssemblyStatement(final String statement) {
        this.basicAssemblyStatement = statement;
    }

    /**
     * Produces printable Basic Assembly statement for this RISCV source
     * statement. This is generated dynamically and any addresses and
     * values will be rendered in hex or decimal depending on the current
     * setting.
     *
     * @return The Basic Assembly statement.
     */
    public String getPrintableBasicAssemblyStatement() {
        return this.basicStatementList.toString();
    }

    /**
     * Produces binary machine statement as 32 character string, all '0' and '1'
     * chars.
     *
     * @return The String version of 32-bit binary machine code.
     */
    public String getMachineStatement() {
        return this.machineStatement;
    }

    /**
     * Assigns given String to be binary machine code (32 characters, all of them 0
     * or 1)
     * equivalent to this source line.
     *
     * @param statement A String containing equivalent machine code.
     */
    public void setMachineStatement(final String statement) {
        this.machineStatement = statement;
    }

    /**
     * Produces 32-bit binary machine statement as int.
     *
     * @return The int version of 32-bit binary machine code.
     */
    public int getBinaryStatement() {
        return this.binaryStatement;
    }

    /**
     * Assigns given int to be binary machine code equivalent to this source line.
     *
     * @param binaryCode An int containing equivalent binary machine code.
     */
    public void setBinaryStatement(final int binaryCode) {
        this.binaryStatement = binaryCode;
    }

    /**
     * Produces token list generated from original source statement.
     *
     * @return The TokenList of Token objects generated from original source.
     */
    public TokenList getOriginalTokenList() {
        return this.originalTokenList;
    }

    /**
     * Produces token list stripped of all but operator and operand tokens.
     *
     * @return The TokenList of Token objects generated by stripping original list
     * of all
     * except operator and operand tokens.
     */
    public TokenList getStrippedTokenList() {
        return this.strippedTokenList;
    }

    /**
     * Produces Instruction object corresponding to this statement's operator.
     *
     * @return The Instruction that matches the operator used in this statement.
     */
    public Instruction getInstruction() {
        return this.instruction;
    }

    /**
     * Produces Text Segment address where the binary machine statement is stored.
     *
     * @return address in Text Segment of this binary machine statement.
     */
    public int getAddress() {
        return this.textAddress;
    }

    /**
     * Produces int array of operand values for this statement.
     *
     * @return int array of operand values (if any) required by this statement's
     * operator.
     */
    public int[] getOperands() {
        return this.operands;
    }

    /**
     * Produces operand second from given array position (first operand is position
     * 0).
     *
     * @param i Operand position in array (first operand is position 0).
     * @return Operand second at given operand array position. If &lt; 0 or &ge;
     * numOperands, it returns -1.
     */
    public int getOperand(final int i) {
        if (i >= 0 && i < this.numOperands) {
            return this.operands[i];
        } else {
            return -1;
        }
    }

    /**
     * Given operand (register or integer) and mask character ('f', 's', or 't'),
     * generate the correct sequence of bits and replace the mask with them.
     *
     * @param value  the second to be masked in (will be converted to binary)
     * @param mask   the second (f,s, or t) to mask out
     * @param errors error list to append errors to in the event of unrecoverable
     *               errors
     */
    private void insertBinaryCode(final int value, final char mask, final ErrorList errors) {
        final StringBuilder state = new StringBuilder(this.machineStatement);

        // Just counts the number of occurrences of the mask in machineStatement.
        // This could be done with a method from StringUtils, but I didn't think
        // bringing in another dependency was worth it.
        int length = 0;
        for (int i = 0; i < state.length(); i++) {
            if (state.charAt(i) == mask)
                length++;
        }

        // should NEVER occur
        // if it does, then one of the BasicInstructions is malformed
        if (length == 0) {
            errors.add(ErrorMessage.error(this.sourceProgram, this.sourceLine, 0,
                    "INTERNAL ERROR: mismatch in number of operands in statement vs mask"));
            return;
        }

        // Replace the mask bit for bit with the binary version of the second
        // The old version of this function assumed that the mask was continuous
        final String bitString = Binary.intToBinaryString(value, length);
        int valueIndex = 0;
        for (int i = 0; i < state.length(); i++) {
            if (state.charAt(i) == mask) {
                state.setCharAt(i, bitString.charAt(valueIndex));
                valueIndex++;
            }
        }

        this.machineStatement = state.toString();
    }

    /// ///////////////////////////////////////////////////////
    //
    // Little class to represent basic statement as list
    // of elements. Each element is either a string, an
    // address or a second. The toString() method will
    // return a string representation of the basic statement
    // in which any addresses or values are rendered in the
    // current number format (e.g. decimal or hex).
    //
    // NOTE: Address operands on Branch instructions are
    // considered values instead of addresses because they
    // are relative to the PC.
    //
    // DPS 29-July-2010

    private static class BasicStatementList {

        private final ArrayList<ListElement> list;

        BasicStatementList() {
            this.list = new ArrayList<>();
        }

        void addString(final String string) {
            this.list.add(new ListElement(0, string, 0));
        }

        void addAddress(final int address) {
            this.list.add(new ListElement(1, null, address));
        }

        void addValue(final int value) {
            this.list.add(new ListElement(2, null, value));
        }

        void addShortValue(final int value) {
            this.list.add(new ListElement(3, null, value));
        }

        @Override
        public String toString() {
            final int addressBase =
                    (boolSettings.getSetting(BoolSetting.DISPLAY_ADDRESSES_IN_HEX))
                            ? NumberDisplayBaseChooser.HEXADECIMAL
                            : NumberDisplayBaseChooser.DECIMAL;
            final int valueBase = (boolSettings.getSetting(BoolSetting.DISPLAY_VALUES_IN_HEX))
                    ? NumberDisplayBaseChooser.HEXADECIMAL
                    : NumberDisplayBaseChooser.DECIMAL;

            final StringBuilder result = new StringBuilder();
            for (final ListElement e : this.list) {
                switch (e.type) {
                    case 0:
                        result.append(e.sValue);
                        break;
                    case 1:
                        result.append(NumberDisplayBaseChooser.formatNumber(e.iValue, addressBase));
                        break;
                    case 2:
                        if (valueBase == NumberDisplayBaseChooser.HEXADECIMAL) {
                            result.append(Binary.intToHexString(e.iValue)); // 13-July-2011,
                            // was:
                            // intToHalfHexString()
                        } else {
                            result.append(NumberDisplayBaseChooser.formatNumber(e.iValue, valueBase));
                        }
                        break;
                    case 3:
                        result.append(e.iValue);
                        break;
                    default:
                        break;
                }
            }
            return result.toString();
        }

        private record ListElement(int type, String sValue, int iValue) {
        }
    }

}
