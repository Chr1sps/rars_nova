package rars;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.Range;
import rars.api.DisplayFormat;
import rars.assembler.SourceLine;
import rars.assembler.TokenList;
import rars.assembler.TokenType;
import rars.riscv.*;
import rars.riscv.hardware.registers.Register;
import rars.settings.BoolSetting;
import rars.util.BinaryUtilsKt;
import rars.venus.NumberDisplayBasePicker;

import java.util.ArrayList;

import static java.util.Objects.requireNonNull;

sealed interface ListElement {
    record String(@NotNull java.lang.String value) implements ListElement {
    }

    record Address(int value) implements ListElement {
    }

    record Value(int value) implements ListElement {
    }

    record ShortValue(int value) implements ListElement {
    }
}

/**
 * Represents one assembly/machine statement. This represents the "bare machine"
 * level.
 * Pseudo-instructions have already been processed at this point and each
 * assembly
 * statement generated by them is one of these.
 *
 * @author Pete Sanderson and Jason Bumgarner
 * @version August 2003
 */
public final class ProgramStatement implements Comparable<ProgramStatement> {
    private static final @NotNull String INVALID_OPERATOR = "<INVALID>";
    public final @Nullable SourceLine sourceLine;
    private final @Nullable TokenList originalTokenList, strippedTokenList;
    private final @NotNull BasicStatementList basicStatementList;
    private final @NotNull ArrayList<@NotNull Integer> operands;
    private final @NotNull Instruction instruction;
    private final int textAddress;
    private String basicAssemblyStatement;
    private String machineStatement;
    private int binaryStatement;

    /**
     * Constructor for ProgramStatement when there are links back to all source and
     * token
     * information. These can be used by a debugger later on.
     *
     * @param origTokenList
     *     Complete list of Token objects (includes labels,
     *     comments, parentheses, etc)
     * @param strippedTokenList
     *     List of Token objects with all but operators and
     *     operands removed.
     * @param instruction
     *     The Instruction object for this statement's
     *     operator.
     * @param textAddress
     *     The Text Segment address in memory where the binary
     *     machine code for this statement
     *     is stored.
     * @param sourceLine
     *     A SourceLine object containing the information about
     *     the program this statement relates to and the statement's
     *     position in code.
     */
    public ProgramStatement(
        final @Nullable TokenList origTokenList,
        final @Nullable TokenList strippedTokenList,
        final @NotNull Instruction instruction,
        final int textAddress,
        final @Nullable SourceLine sourceLine
    ) {
        this.originalTokenList = origTokenList;
        this.strippedTokenList = strippedTokenList;
        this.operands = new ArrayList<>(5);
        this.instruction = instruction;
        this.textAddress = textAddress;
        this.sourceLine = sourceLine;
        this.basicAssemblyStatement = null;
        this.basicStatementList = new BasicStatementList();
        this.machineStatement = null;
        this.binaryStatement = 0; // nop, or sll $0, $0, 0 (32 bits of 0's)
    }

    /**
     * Constructor for ProgramStatement used only for writing a binary machine
     * instruction with no source code to refer back to. Originally supported
     * only NOP instruction (all zeroes), but extended in release 4.4 to support
     * all basic instructions. This was required for the self-modifying code
     * feature.
     *
     * @param binaryStatement
     *     The 32-bit machine code.
     * @param textAddress
     *     The Text Segment address in memory where the binary
     *     machine code for this statement
     *     is stored.
     */
    public ProgramStatement(
        final int binaryStatement,
        final int textAddress
    ) {
        this.binaryStatement = binaryStatement;
        this.textAddress = textAddress;
        this.originalTokenList = null;
        this.strippedTokenList = null;
        this.sourceLine = null;
        this.basicAssemblyStatement = null;
        this.machineStatement = null;
        this.operands = new ArrayList<>(5);
        final var foundInstruction = InstructionsRegistry.findBasicInstructionByBinaryCode(
            binaryStatement);
        assert foundInstruction != null : "ERROR: basic instruction not found for this opcode.";
        this.instruction = foundInstruction;
        final var opCodeMask = foundInstruction.operationMask;
        final var format = foundInstruction.getInstructionFormat();
        switch (format) {
            case J_FORMAT -> {
                this.operands.add(readBinaryCode(
                    opCodeMask,
                    Instruction.operandMask[0],
                    binaryStatement
                ));
                this.operands.add(fromJumpImmediate(readBinaryCode(
                    opCodeMask,
                    Instruction.operandMask[1],
                    binaryStatement
                )));
            }
            case B_FORMAT -> {
                this.operands.add(readBinaryCode(
                    opCodeMask,
                    Instruction.operandMask[0],
                    binaryStatement
                ));
                this.operands.add(readBinaryCode(
                    opCodeMask,
                    Instruction.operandMask[1],
                    binaryStatement
                ));
                this.operands.add(fromBranchImmediate(readBinaryCode(
                    opCodeMask,
                    Instruction.operandMask[2],
                    binaryStatement
                )));
            }
            default -> {
                for (final var mask : Instruction.operandMask) {
                    if (opCodeMask.indexOf(mask) != -1) {
                        this.operands.add(readBinaryCode(
                            opCodeMask,
                            mask,
                            binaryStatement
                        ));
                    }
                }
            }
        }
        this.basicStatementList = buildBasicStatementListFromBinaryCode(
            foundInstruction,
            this.operands
        );
    }

    // region Statics

    private static int toJumpImmediate(int address) {
        // trying to produce immediate[20:1] where immediate = address[20|10:1|11|19:12]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 19)) | // keep the top bit in the same place
            ((address & 0x3FF) << 9) | // move address[10:1] to the right place
            ((address & (1 << 10)) >> 2) | // move address[11] to the right place
            ((address & 0x7F800) >> 11); // move address[19:12] to the right place
    }

    private static int fromJumpImmediate(final int immediate) {
        // trying to produce address[20:0] where immediate = address[20|10:1|11|19:12]
        final int tmp = ((immediate) & (1 << 19)) | // keep the top bit in the same place
            ((immediate & 0x7FE00) >> 9) | // move address[10:1] to the right place
            ((immediate & (1 << 8)) << 2) | // move address[11] to the right place
            ((immediate & 0xFF) << 11); // move address[19:12] to the right place
        return (tmp << 12) >> 11; // sign-extend and add extra 0
    }

    private static int toBranchImmediate(int address) {
        // trying to produce imm[12:1] where immediate = address[12|10:1|11]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 11)) | // keep the top bit in the same place
            ((address & 0x3FF) << 1) | // move address[10:1] to the right place
            ((address & (1 << 10)) >> 10); // move address[11] to the right place
    }

    private static int fromBranchImmediate(final int immediate) {
        // trying to produce address[12:0] where immediate = address[12|10:1|11]
        final int tmp = (immediate & (1 << 11)) | // keep the top bit in the same place
            ((immediate & 0x7FE) >> 1) | // move address[10:1] to the right place
            ((immediate & 1) << 10); // move address[11] to the right place
        return (tmp << 20) >> 19; // sign-extend and add extra 0
    }

    /**
     * Reads an operand from a binary statement according to a mask and format
     * <p>
     * i.e.
     *
     * <pre>
     * 0b01001 == readBinaryCode("ttttttttttttttsssss010fffff1101001", 'f',
     *         0b0101000001000001000010010011101001)
     * </pre>
     *
     * @param format
     *     the format of the full binary statement (all operands
     *     present)
     * @param mask
     *     the value (f,s, or t) to mask out
     * @param binaryStatement
     *     the binary statement to read from
     * @return the bits read pushed to the right
     */
    private static int readBinaryCode(
        final String format,
        final char mask,
        final int binaryStatement
    ) {
        int out = 0;
        for (int i = 0; i < 32; i++) {
            if (format.charAt(i) == mask) {
                // if the mask says to read, shift the output left and add substitute bit i
                out = (out << 1) | ((binaryStatement >> (31 - i)) & 1);
            }
        }
        return out;
    }

    /**
     * Given a model BasicInstruction and the assembled (not source) operand array
     * for a statement,
     * this method will construct the corresponding basic instruction list. This
     * method is
     * used by the constructor that is given only the int address and binary code.
     * It is not
     * intended to be used when source code is available.
     */
    private static @NotNull BasicStatementList buildBasicStatementListFromBinaryCode(
        final @NotNull BasicInstruction instr,
        final @NotNull ArrayList<@NotNull Integer> operands
    ) {
        final var result = new BasicStatementList();
        result.addString(instr.mnemonic + ' ');
        final var tokenList = InstructionsRegistry.getTokenList(instr);
        // index 0 is operator; operands start at index 1
        int tokenListCounter = 1;
        for (final var operand : operands) {
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if (tokenListCounter > 1 && tokenListCounter < tokenList.size()) {
                final TokenType thisTokenType = tokenList.get(tokenListCounter)
                    .getType();
                if (thisTokenType != TokenType.LEFT_PAREN && thisTokenType != TokenType.RIGHT_PAREN) {
                    result.addString(",");
                }
            }
            boolean notOperand = true;
            while (notOperand && tokenListCounter < tokenList.size()) {
                final var tokenType = tokenList.get(tokenListCounter).getType();
                switch (tokenType) {
                    case LEFT_PAREN -> result.addString("(");
                    case RIGHT_PAREN -> result.addString(")");
                    case REGISTER_NAME, REGISTER_NUMBER, FP_REGISTER_NAME -> {
                        final var marker = (tokenType == TokenType.FP_REGISTER_NAME)
                            ? "f"
                            : "x";
                        result.addString(marker + operand);
                        notOperand = false;
                    }
                    case INTEGER_12 -> {
                        result.addValue((operand << 20) >> 20);
                        notOperand = false;
                    }
                    case ROUNDING_MODE -> {
                        String value = "invalid";
                        if (operand >= 0 && operand < 8) {
                            final var modes = new String[]{
                                "rne",
                                "rtz",
                                "rdn",
                                "rup",
                                "rmm",
                                "invalid",
                                "invalid",
                                "dyn"
                            };
                            value = modes[operand];
                        }
                        result.addString(value);
                        notOperand = false;
                    }
                    default -> {
                        result.addValue(operand);
                        notOperand = false;
                    }
                }
                tokenListCounter++;
            }
        }
        while (tokenListCounter < tokenList.size()) {
            final TokenType tokenType = tokenList.get(tokenListCounter)
                .getType();
            switch (tokenType) {
                case LEFT_PAREN -> result.addString("(");
                case RIGHT_PAREN -> result.addString(")");
            }
            tokenListCounter++;
        }
        return result;
    }

    // endregion Statics

    @Override
    public int compareTo(final ProgramStatement obj1) {
        return Integer.compareUnsigned(this.textAddress, obj1.textAddress);
    }

    /**
     * Given specification of BasicInstruction for this operator, build the
     * corresponding assembly statement in basic assembly format (e.g. substituting
     * register numbers for register names, replacing labels by values).
     *
     * @param errors
     *     The list of assembly errors encountered so far. May add to it
     *     here.
     */
    public void buildBasicStatementFromBasicInstruction(final ErrorList errors) {
        final var firstToken = requireNonNull(this.strippedTokenList)
            .get(0);
        final var firstElement = firstToken.getText() + ' ';
        this.basicStatementList.addString(firstElement); // the operator
        final var basicInstructionBuilder = new StringBuilder(firstElement);
        for (int i = 1; i < this.strippedTokenList.size(); i++) {
            final var token = this.strippedTokenList.get(i);
            final var tokenType = token.getType();
            final var tokenValue = token.getText();
            final String basicStatementElement;
            final @Nullable Register register;
            switch (tokenType) {
                case REGISTER_NUMBER -> {
                    basicStatementElement = tokenValue;
                    basicInstructionBuilder.append(basicStatementElement);
                    register = Globals.REGISTER_FILE.getRegisterByName(
                        tokenValue);
                    this.basicStatementList.addString(basicStatementElement);
                    if (register == null) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid register name"
                        );
                        return;
                    }
                    this.operands.add(register.number);
                }
                case REGISTER_NAME -> {
                    register = Globals.REGISTER_FILE.getRegisterByName(
                        tokenValue);
                    if (register == null) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid register name"
                        );
                        return;
                    }
                    basicStatementElement = "x" + register.number;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                    this.operands.add(register.number);
                }
                case CSR_NAME -> {
                    register = Globals.CS_REGISTER_FILE.getRegisterByName(
                        tokenValue);
                    if (register == null) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid CSR name"
                        );
                        return;
                    }
                    basicInstructionBuilder.append(register.number);
                    this.basicStatementList.addString("" + register.number);
                    this.operands.add(register.number);
                }
                case FP_REGISTER_NAME -> {
                    register = Globals.FP_REGISTER_FILE.getRegisterByName(
                        tokenValue);
                    if (register == null) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid FPU register name"
                        );
                        return;
                    }
                    basicStatementElement = "f" + register.number;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                    this.operands.add(register.number);
                }
                case ROUNDING_MODE -> {
                    final int roundingMode = switch (tokenValue) {
                        case "rne" -> 0;
                        case "rtz" -> 1;
                        case "rdn" -> 2;
                        case "rup" -> 3;
                        case "rmm" -> 4;
                        case "dyn" -> 7;
                        default -> -1;
                    };
                    if (roundingMode == -1) {
                        errors.addTokenError(
                            token,
                            "invalid rounding mode"
                        );
                        return;
                    }
                    basicInstructionBuilder.append(tokenValue);
                    this.basicStatementList.addString(tokenValue);
                    this.operands.add(roundingMode);
                }
                case IDENTIFIER -> {
                    final var localAddress = requireNonNull(this.sourceLine)
                        .program()
                        .getLocalSymbolTable()
                        .getAddress(tokenValue);
                    var address = (localAddress != null)
                        ? localAddress
                        : Globals.GLOBAL_SYMBOL_TABLE.getAddress(tokenValue);
                    if (address == null) {
                        // symbol used without being defined
                        errors.addTokenError(
                            token,
                            "Symbol \"%s\" not found in symbol table.".formatted(
                                tokenValue)
                        );
                        return;
                    }
                    boolean absoluteAddress = true; // (used below)

                    if (this.instruction instanceof BasicInstruction) {
                        final BasicInstructionFormat format =
                            ((BasicInstruction) this.instruction).getInstructionFormat();
                        if (format == BasicInstructionFormat.B_FORMAT) {
                            address -= this.textAddress;
                            if (address >= (1 << 12) || address < -(1 << 12)) {
                                // SPIM flags as warning, I'll flag as error b/c RARS text segment not long
                                // enough for it to be OK.
                                errors.add(ErrorMessage.error(
                                    this.sourceLine.program(),
                                    this.sourceLine.lineNumber(),
                                    0,
                                    "Branch target word address beyond 12-bit range"
                                ));
                                return;
                            }
                            absoluteAddress = false;
                        } else if (format == BasicInstructionFormat.J_FORMAT) {
                            address -= this.textAddress;
                            if (address >= (1 << 20) || address < -(1 << 20)) {
                                errors.add(ErrorMessage.error(
                                    this.sourceLine.program(),
                                    this.sourceLine.lineNumber(),
                                    0,
                                    "Jump target word address beyond 20-bit range"
                                ));
                                return;
                            }
                            absoluteAddress = false;
                        }
                    }
                    basicInstructionBuilder.append(address);
                    if (absoluteAddress) {
                        // record as address if absolute, value if relative
                        this.basicStatementList.addAddress(address);
                    } else {
                        this.basicStatementList.addValue(address);
                    }
                    this.operands.add(address);
                }
                case INTEGER_5, INTEGER_6, INTEGER_12, INTEGER_12U, INTEGER_20,
                     INTEGER_32 -> {

                    final int tempNumeric = BinaryUtilsKt.stringToInt(tokenValue);

                    basicInstructionBuilder.append(tempNumeric);
                    if (tokenType == TokenType.INTEGER_5) {
                        this.basicStatementList.addShortValue(tempNumeric);
                    } else {
                        this.basicStatementList.addValue(tempNumeric);
                    }
                    this.operands.add(tempNumeric);
                }
                default -> {
                    basicStatementElement = tokenValue;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                }
            }
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if ((i < this.strippedTokenList.size() - 1)) {
                final var nextTokenType = this.strippedTokenList.get(i + 1)
                    .getType();
                if (tokenType != TokenType.LEFT_PAREN
                    && tokenType != TokenType.RIGHT_PAREN
                    && nextTokenType != TokenType.LEFT_PAREN
                    && nextTokenType != TokenType.RIGHT_PAREN
                ) {
                    basicInstructionBuilder.append(',');
                    this.basicStatementList.addString(",");
                }
            }
        }
        this.basicAssemblyStatement = basicInstructionBuilder.toString();
    }

    /**
     * Given the current statement in Basic Assembly format (see above), build the
     * 32-bit binary machine code statement.
     *
     * @param errors
     *     The list of assembly errors encountered so far. May add to it
     *     here.
     */
    public void buildMachineStatementFromBasicStatement(final @NotNull ErrorList errors) {
        switch (this.instruction) {
            case final ExtendedInstruction ignored ->
                // This means the pseudo-instruction expansion generated another
                // pseudo-instruction (expansion must be to all basic instructions).
                // This is an error on the part of the pseudo-instruction author.
                errors.add(ErrorMessage.error(
                    this.sourceLine.program(),
                    this.sourceLine.lineNumber(),
                    0,
                    "INTERNAL ERROR: usePseudoInstructions-instruction expansion contained a " +
                        "pseudo-instruction"
                ));
            case final BasicInstruction basic -> {
                // mask indicates bit positions for 'f'irst, 's'econd, 't'hird operand
                this.machineStatement = basic.operationMask;
                final BasicInstructionFormat format = basic.getInstructionFormat();

                if (format == BasicInstructionFormat.J_FORMAT) {
                    this.insertBinaryCode(
                        this.operands.get(0),
                        Instruction.operandMask[0],
                        errors
                    );
                    this.insertBinaryCode(
                        toJumpImmediate(this.operands.get(1)),
                        Instruction.operandMask[1],
                        errors
                    );
                } else if (format == BasicInstructionFormat.B_FORMAT) {
                    this.insertBinaryCode(
                        this.operands.get(0),
                        Instruction.operandMask[0],
                        errors
                    );
                    this.insertBinaryCode(
                        this.operands.get(1),
                        Instruction.operandMask[1],
                        errors
                    );
                    this.insertBinaryCode(
                        toBranchImmediate(this.operands.get(2)),
                        Instruction.operandMask[2],
                        errors
                    );
                } else {
                    // Everything else is normal
                    for (int i = 0; i < this.operands.size(); i++) {
                        this.insertBinaryCode(
                            this.operands.get(i),
                            Instruction.operandMask[i],
                            errors
                        );
                    }
                }
                binaryStatement = Integer.parseUnsignedInt(machineStatement, 2);
            }
            case null -> throw new IllegalStateException("Instruction is null");
        }
    }

    /**
     * Crude attempt at building String representation of this complex structure.
     *
     * @return A String representing the ProgramStatement.
     */
    @Override
    public @NotNull String toString() {
        final var builder = new StringBuilder();
        final var textAddressString = "[%s]".formatted(BinaryUtilsKt.intToHexStringWithPrefix(
            this.textAddress));
        builder.append(textAddressString);
        if (this.basicAssemblyStatement != null) {
            final var firstSpaceIndex = this.basicAssemblyStatement.indexOf(' ');
            final var instruction = this.basicAssemblyStatement.substring(
                0,
                firstSpaceIndex
            );
            final var operands = this.basicAssemblyStatement.substring(
                firstSpaceIndex + 1);
            builder.append(" %-7s %-21s".formatted(instruction, operands));
        } else {
            builder.append(this.getPrintableBasicAssemblyStatement());
        }
        if (this.machineStatement != null) {
            final var machineStatementString = "| %s | %s|%s|%s|%s".formatted(
                BinaryUtilsKt.binaryStringToHexString(this.machineStatement),
                this.machineStatement.substring(0, 8),
                this.machineStatement.substring(8, 16),
                this.machineStatement.substring(16, 24),
                this.machineStatement.substring(24, 32)
            );
            builder.append(machineStatementString);
        }
        return builder.toString();
    }

    /**
     * Produces RISCVprogram object representing the source file containing this
     * statement.
     *
     * @return The RISCVprogram object. May be null...
     */
    public @Nullable RISCVProgram getSourceProgram() {
        return (this.sourceLine == null) ? null : this.sourceLine.program();
    }

    /**
     * Produces Basic Assembly statement for this RISCV source statement.
     * All numeric values are in decimal.
     *
     * @return The Basic Assembly statement.
     */
    public String getBasicAssemblyStatement() {
        return this.basicAssemblyStatement;
    }

    /**
     * Produces printable Basic Assembly statement for this RISCV source
     * statement. This is generated dynamically and any addresses and
     * values will be rendered in hex or decimal depending on the current
     * setting.
     *
     * @return The Basic Assembly statement.
     */
    public @NotNull String getPrintableBasicAssemblyStatement() {
        return this.basicStatementList.toString();
    }

    /**
     * Produces 32-bit binary machine statement as int.
     *
     * @return The int version of 32-bit binary machine code.
     */
    public int getBinaryStatement() {
        return this.binaryStatement;
    }

    /**
     * Produces token list generated from original source statement.
     *
     * @return The TokenList of Token objects generated from original source.
     */
    public @Nullable TokenList getOriginalTokenList() {
        return this.originalTokenList;
    }

    /**
     * Produces Instruction object corresponding to this statement's operator.
     *
     * @return The Instruction that matches the operator used in this statement.
     */
    public @NotNull Instruction getInstruction() {
        return this.instruction;
    }

    /**
     * Produces Text Segment address where the binary machine statement is stored.
     *
     * @return address in Text Segment of this binary machine statement.
     */
    public int getAddress() {
        return this.textAddress;
    }

    /**
     * Returns true if the statement contains an operand of the given index.
     */
    public boolean hasOperand(final int index) {
        return index > 0 && index < this.operands.size();
    }

    /**
     * Produces operand value from given array position (first operand is position
     * 0).
     *
     * @param i
     *     Operand position in array (first operand is position 0).
     * @return Operand value at given operand array position.
     * @throws IndexOutOfBoundsException
     *     if illegal operand position.
     */
    public int getOperand(@Range(from = 0L, to = 4L) final int i) throws
        IndexOutOfBoundsException {
        return this.operands.get(i);
    }

    /**
     * Given operand (register or integer) and mask character ('f', 's', or 't'),
     * generate the correct sequence of bits and replace the mask with them.
     *
     * @param value
     *     the value to be masked in (will be converted to binary)
     * @param mask
     *     the value (f,s, or t) to mask out
     * @param errors
     *     error list to append errors to in the event of unrecoverable
     *     errors
     */
    private void insertBinaryCode(
        final int value,
        final char mask,
        final ErrorList errors
    ) {
        final var stateBuilder = new StringBuilder(this.machineStatement);

        // Just counts the number of occurrences of the mask in machineStatement.
        // This could be done with a method from StringUtils, but I didn't think
        // bringing in another dependency was worth it.
        int length = 0;
        for (int i = 0; i < stateBuilder.length(); i++) {
            if (stateBuilder.charAt(i) == mask) {
                length++;
            }
        }

        // should NEVER occur
        // if it does, then one of the BasicInstructions is malformed
        if (length == 0) {
            errors.add(ErrorMessage.error(
                this.sourceLine.program(),
                this.sourceLine.lineNumber(),
                0,
                "INTERNAL ERROR: mismatch in number of operands in statement vs mask"
            ));
            return;
        }

        // Replace the mask bit for bit with the binary version of the value
        // The old version of this function assumed that the mask was continuous
        final String bitString = BinaryUtilsKt.intToBinaryString(
            value,
            length
        );
        int valueIndex = 0;
        for (int i = 0; i < stateBuilder.length(); i++) {
            if (stateBuilder.charAt(i) == mask) {
                stateBuilder.setCharAt(
                    i,
                    bitString.charAt(valueIndex)
                );
                valueIndex++;
            }
        }

        this.machineStatement = stateBuilder.toString();
    }

}

final class BasicStatementList {
    private final @NotNull ArrayList<@NotNull ListElement> list;

    BasicStatementList() {
        list = new ArrayList<>();
    }

    void addString(final @NotNull String value) {
        list.add(new ListElement.String(value));
    }

    void addAddress(final int value) {
        list.add(new ListElement.Address(value));
    }

    void addValue(final int value) {
        list.add(new ListElement.Value(value));
    }

    void addShortValue(final int value) {
        list.add(new ListElement.ShortValue(value));
    }

    @Override
    public @NotNull String toString() {
        final var addressFormat = (Globals.BOOL_SETTINGS.getSetting(BoolSetting.DISPLAY_ADDRESSES_IN_HEX))
            ? DisplayFormat.HEX
            : DisplayFormat.DECIMAL;
        final var valueFormat = (Globals.BOOL_SETTINGS.getSetting(BoolSetting.DISPLAY_VALUES_IN_HEX))
            ? DisplayFormat.HEX
            : DisplayFormat.DECIMAL;

        final var result = new StringBuilder();
        for (final var element : list) {
            final var toAppend = switch (element) {
                case final ListElement.Address address ->
                    NumberDisplayBasePicker.formatNumber(
                        address.value(),
                        addressFormat
                    );
                case final ListElement.ShortValue shortValue ->
                    shortValue.value();
                case final ListElement.String string -> string.value();
                case final ListElement.Value value -> {
                    if (valueFormat == DisplayFormat.HEX) {
                        yield BinaryUtilsKt.intToHexStringWithPrefix(value.value());
                    } else {
                        yield NumberDisplayBasePicker.formatNumber(
                            value.value(),
                            valueFormat
                        );
                    }
                }
            };
            result.append(toAppend);
        }
        return result.toString();
    }
}
