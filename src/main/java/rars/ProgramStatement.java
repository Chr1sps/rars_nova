package rars;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import rars.assembler.SymbolTable;
import rars.assembler.TokenList;
import rars.assembler.TokenType;
import rars.riscv.*;
import rars.riscv.hardware.ControlAndStatusRegisterFile;
import rars.riscv.hardware.FloatingPointRegisterFile;
import rars.riscv.hardware.RegisterFile;
import rars.settings.BoolSetting;
import rars.util.BinaryUtils;
import rars.venus.NumberDisplayBaseChooser;

import java.io.File;
import java.util.ArrayList;
import java.util.Objects;

import static rars.settings.BoolSettings.BOOL_SETTINGS;


/*
Copyright (c) 2003-2013,  Pete Sanderson and Kenneth Vollmar

Developed by Pete Sanderson (psanderson@otterbein.edu)
and Kenneth Vollmar (kenvollmar@missouristate.edu)

Permission is hereby granted, free of charge, to any person obtaining 
a copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject 
to the following conditions:

The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(MIT license, http://www.opensource.org/licenses/mit-license.html)
 */

/**
 * Represents one assembly/machine statement. This represents the "bare machine"
 * level.
 * Pseudo-instructions have already been processed at this point and each
 * assembly
 * statement generated by them is one of these.
 *
 * @author Pete Sanderson and Jason Bumgarner
 * @version August 2003
 */
public final class ProgramStatement implements Comparable<ProgramStatement> {
    private static final @NotNull String invalidOperator = "<INVALID>";
    private final @Nullable RISCVProgram sourceProgram;
    private final @Nullable TokenList originalTokenList, strippedTokenList;
    private final @NotNull BasicStatementList basicStatementList;
    private final @NotNull ArrayList<@NotNull Integer> operands;
    private final @Nullable Instruction instruction;
    private final int textAddress;
    private final @NotNull String source;
    private final int sourceLine;
    private String basicAssemblyStatement;
    private String machineStatement;
    private int binaryStatement;

    /**
     * Constructor for ProgramStatement when there are links back to all source and
     * token
     * information. These can be used by a debugger later on.
     *
     * @param sourceProgram
     *     The RISCVprogram object that contains this statement
     * @param source
     *     The corresponding RISCV source statement.
     * @param origTokenList
     *     Complete list of Token objects (includes labels,
     *     comments, parentheses, etc)
     * @param strippedTokenList
     *     List of Token objects with all but operators and
     *     operands removed.
     * @param instruction
     *     The Instruction object for this statement's
     *     operator.
     * @param textAddress
     *     The Text Segment address in memory where the binary
     *     machine code for this statement
     *     is stored.
     * @param sourceLine
     *     a int
     */
    public ProgramStatement(
        final @Nullable RISCVProgram sourceProgram,
        final @NotNull String source,
        final @Nullable TokenList origTokenList,
        final @Nullable TokenList strippedTokenList,
        final @NotNull Instruction instruction,
        final int textAddress,
        final int sourceLine
    ) {
        this.sourceProgram = sourceProgram;
        this.source = source;
        this.originalTokenList = origTokenList;
        this.strippedTokenList = strippedTokenList;
        this.operands = new ArrayList<>(5);
        this.instruction = instruction;
        this.textAddress = textAddress;
        this.sourceLine = sourceLine;
        this.basicAssemblyStatement = null;
        this.basicStatementList = new BasicStatementList();
        this.machineStatement = null;
        this.binaryStatement = 0; // nop, or sll $0, $0, 0 (32 bits of 0's)
    }

    /**
     * Constructor for ProgramStatement used only for writing a binary machine
     * instruction with no source code to refer back to. Originally supported
     * only NOP instruction (all zeroes), but extended in release 4.4 to support
     * all basic instructions. This was required for the self-modifying code
     * feature.
     *
     * @param binaryStatement
     *     The 32-bit machine code.
     * @param textAddress
     *     The Text Segment address in memory where the binary
     *     machine code for this statement
     *     is stored.
     */
    public ProgramStatement(final int binaryStatement, final int textAddress) {
        this.sourceProgram = null;
        this.binaryStatement = binaryStatement;
        this.textAddress = textAddress;
        this.originalTokenList = this.strippedTokenList = null;
        this.source = "";
        this.sourceLine = -1;
        this.machineStatement = this.basicAssemblyStatement = null;
        final var instr = InstructionsRegistry.findBasicInstructionByBinaryCode(binaryStatement);
        this.operands = new ArrayList<>(5);
        if (instr == null) {
            this.instruction = null;
        } else {
            this.instruction = instr;
            final var opCodeMask = instr.getOperationMask();
            final var format = instr.getInstructionFormat();
            switch (format) {
                case J_FORMAT -> {
                    this.operands.add(readBinaryCode(
                        opCodeMask,
                        Instruction.operandMask[0],
                        binaryStatement
                    ));
                    this.operands.add(fromJumpImmediate(readBinaryCode(
                        opCodeMask,
                        Instruction.operandMask[1],
                        binaryStatement
                    )));
                }
                case B_FORMAT -> {
                    this.operands.add(readBinaryCode(
                        opCodeMask,
                        Instruction.operandMask[0],
                        binaryStatement
                    ));
                    this.operands.add(readBinaryCode(
                        opCodeMask,
                        Instruction.operandMask[1],
                        binaryStatement
                    ));
                    this.operands.add(fromBranchImmediate(readBinaryCode(
                        opCodeMask,
                        Instruction.operandMask[2],
                        binaryStatement
                    )));
                }
                default -> {
                    for (final var mask : Instruction.operandMask) {
                        if (opCodeMask.indexOf(mask) != -1) {
                            this.operands.add(readBinaryCode(
                                opCodeMask,
                                mask,
                                binaryStatement
                            ));
                        }
                    }
                }
            }
        }
        this.basicStatementList = buildBasicStatementListFromBinaryCode(
            instr,
            this.operands
        );
    }

    private static int toJumpImmediate(int address) {
        // trying to produce immediate[20:1] where immediate = address[20|10:1|11|19:12]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 19)) | // keep the top bit in the same place
            ((address & 0x3FF) << 9) | // move address[10:1] to the right place
            ((address & (1 << 10)) >> 2) | // move address[11] to the right place
            ((address & 0x7F800) >> 11); // move address[19:12] to the right place
    }

    private static int fromJumpImmediate(final int immediate) {
        // trying to produce address[20:0] where immediate = address[20|10:1|11|19:12]
        final int tmp = ((immediate) & (1 << 19)) | // keep the top bit in the same place
            ((immediate & 0x7FE00) >> 9) | // move address[10:1] to the right place
            ((immediate & (1 << 8)) << 2) | // move address[11] to the right place
            ((immediate & 0xFF) << 11); // move address[19:12] to the right place
        return (tmp << 12) >> 11; // sign-extend and add extra 0
    }

    private static int toBranchImmediate(int address) {
        // trying to produce imm[12:1] where immediate = address[12|10:1|11]
        address = address >> 1; // Shift it down one byte
        return (address & (1 << 11)) | // keep the top bit in the same place
            ((address & 0x3FF) << 1) | // move address[10:1] to the right place
            ((address & (1 << 10)) >> 10); // move address[11] to the right place
    }

    private static int fromBranchImmediate(final int immediate) {
        // trying to produce address[12:0] where immediate = address[12|10:1|11]
        final int tmp = (immediate & (1 << 11)) | // keep the top bit in the same place
            ((immediate & 0x7FE) >> 1) | // move address[10:1] to the right place
            ((immediate & 1) << 10); // move address[11] to the right place
        return (tmp << 20) >> 19; // sign-extend and add extra 0
    }

    /**
     * Reads an operand from a binary statement according to a mask and format
     * <p>
     * i.e.
     *
     * <pre>
     * 0b01001 == readBinaryCode("ttttttttttttttsssss010fffff1101001", 'f',
     *         0b0101000001000001000010010011101001)
     * </pre>
     *
     * @param format
     *     the format of the full binary statement (all operands
     *     present)
     * @param mask
     *     the second (f,s, or t) to mask out
     * @param binaryStatement
     *     the binary statement to read from
     * @return the bits read pushed to the right
     */
    private static int readBinaryCode(final String format, final char mask, final int binaryStatement) {
        int out = 0;
        for (int i = 0; i < 32; i++) {
            if (format.charAt(i) == mask) {
                // if the mask says to read, shift the output left and add substitute bit i
                out = (out << 1) | ((binaryStatement >> (31 - i)) & 1);
            }
        }
        return out;
    }

    /**
     * Given a model BasicInstruction and the assembled (not source) operand array
     * for a statement,
     * this method will construct the corresponding basic instruction list. This
     * method is
     * used by the constructor that is given only the int address and binary code.
     * It is not
     * intended to be used when source code is available. DPS 11-July-2013
     */
    private static @NotNull BasicStatementList buildBasicStatementListFromBinaryCode(
        final BasicInstruction instr,
        final @NotNull ArrayList<@NotNull Integer> operands
    ) {
        final BasicStatementList statementList = new BasicStatementList();
        int tokenListCounter = 1; // index 0 is operator; operands start at index 1
        if (instr == null) {
            statementList.addString(invalidOperator);
            return statementList;
        } else {
            statementList.addString(instr.mnemonic + " ");
        }
        final var tokenList = InstructionsRegistry.getTokenList(instr);
        for (final var operand : operands) {
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if (tokenListCounter > 1 && tokenListCounter < tokenList.size()) {
                final TokenType thisTokenType = tokenList.get(tokenListCounter).getType();
                if (thisTokenType != TokenType.LEFT_PAREN && thisTokenType != TokenType.RIGHT_PAREN) {
                    statementList.addString(",");
                }
            }
            boolean notOperand = true;
            while (notOperand && tokenListCounter < tokenList.size()) {
                final var tokenType = tokenList.get(tokenListCounter).getType();
                switch (tokenType) {
                    case LEFT_PAREN -> statementList.addString("(");
                    case RIGHT_PAREN -> statementList.addString(")");
                    case REGISTER_NAME, REGISTER_NUMBER, FP_REGISTER_NAME -> {
                        final var marker = (tokenType == TokenType.FP_REGISTER_NAME) ? "f" : "x";
                        statementList.addString(marker + operand);
                        notOperand = false;
                    }
                    case INTEGER_12 -> {
                        statementList.addValue((operand << 20) >> 20);
                        notOperand = false;
                    }
                    case ROUNDING_MODE -> {
                        final var modes = new String[]{"rne", "rtz", "rdn", "rup", "rmm", "invalid", "invalid", "dyn"};
                        String value = "invalid";
                        if (operand >= 0 && operand < 8) {
                            value = modes[operand];
                        }
                        statementList.addString(value);
                        notOperand = false;
                    }
                    default -> {
                        statementList.addValue(operand);
                        notOperand = false;
                    }
                }
                tokenListCounter++;
            }
        }
        while (tokenListCounter < tokenList.size()) {
            final TokenType tokenType = tokenList.get(tokenListCounter).getType();
            switch (tokenType) {
                case LEFT_PAREN -> statementList.addString("(");
                case RIGHT_PAREN -> statementList.addString(")");
            }
            tokenListCounter++;
        }
        return statementList;
    } // buildBasicStatementListFromBinaryCode()

    @Override
    public int compareTo(final ProgramStatement obj1) {
        final int addr1 = this.getAddress();
        final int addr2 = obj1.getAddress();
        return (addr1 < 0 && addr2 >= 0 || addr1 >= 0 && addr2 < 0) ? addr2 : addr1 - addr2;
    }

    /**
     * Given specification of BasicInstruction for this operator, build the
     * corresponding assembly statement in basic assembly format (e.g. substituting
     * register numbers for register names, replacing labels by values).
     *
     * @param errors
     *     The list of assembly errors encountered so far. May add to it
     *     here.
     */
    public void buildBasicStatementFromBasicInstruction(final ErrorList errors) {
        final var firstToken = Objects.requireNonNull(this.strippedTokenList).get(0);
        final var firstElement = firstToken.getText() + " ";
        final var basicInstructionBuilder = new StringBuilder(firstElement);
        this.basicStatementList.addString(firstElement); // the operator
        for (int i = 1; i < this.strippedTokenList.size(); i++) {
            final var token = this.strippedTokenList.get(i);
            final var tokenType = token.getType();
            final var tokenValue = token.getText();
            final String basicStatementElement;
            final int registerNumber;
            switch (tokenType) {
                case REGISTER_NUMBER -> {
                    basicStatementElement = tokenValue;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                    try {
                        registerNumber = RegisterFile.getRegister(tokenValue).getNumber();
                    } catch (final Exception e) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid register name"
                        );
                        return;
                    }
                    this.operands.add(registerNumber);
                }
                case REGISTER_NAME -> {
                    registerNumber = RegisterFile.getRegister(tokenValue).getNumber();
                    basicStatementElement = "x" + registerNumber;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                    if (registerNumber < 0) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid register name"
                        );
                        return;
                    }
                    this.operands.add(registerNumber);
                }
                case CSR_NAME -> {
                    registerNumber = ControlAndStatusRegisterFile.getRegister(tokenValue).getNumber();
                    if (registerNumber < 0) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid CSR name"
                        );
                        return;
                    }
                    basicInstructionBuilder.append(registerNumber);
                    this.basicStatementList.addString("" + registerNumber);
                    this.operands.add(registerNumber);
                }
                case FP_REGISTER_NAME -> {
                    registerNumber = FloatingPointRegisterFile.getRegister(tokenValue).getNumber();
                    basicStatementElement = "f" + registerNumber;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                    if (registerNumber < 0) {
                        // should never happen; should be caught before now...
                        errors.addTokenError(
                            token,
                            "invalid FPU register name"
                        );
                        return;
                    }
                    this.operands.add(registerNumber);
                }
                case ROUNDING_MODE -> {
                    final int rounding_mode = switch (tokenValue) {
                        case "rne" -> 0;
                        case "rtz" -> 1;
                        case "rdn" -> 2;
                        case "rup" -> 3;
                        case "rmm" -> 4;
                        case "dyn" -> 7;
                        default -> -1;
                    };
                    if (rounding_mode == -1) {
                        errors.addTokenError(
                            token,
                            "invalid rounding mode"
                        );
                        return;
                    }
                    basicInstructionBuilder.append(tokenValue);
                    this.basicStatementList.addString(tokenValue);
                    this.operands.add(rounding_mode);
                }
                case IDENTIFIER -> {
                    int address =
                        Objects.requireNonNull(this.sourceProgram)
                            .getLocalSymbolTable()
                            .getAddressLocalOrGlobal(tokenValue);
                    if (address == SymbolTable.NOT_FOUND) { // symbol used without being defined
                        errors.addTokenError(
                            token,
                            "Symbol \"%s\" not found in symbol table.".formatted(tokenValue)
                        );
                        return;
                    }
                    boolean absoluteAddress = true; // (used below)

                    if (this.instruction instanceof BasicInstruction) {
                        final BasicInstructionFormat format =
                            ((BasicInstruction) this.instruction).getInstructionFormat();
                        if (format == BasicInstructionFormat.B_FORMAT) {
                            address -= this.textAddress;
                            if (address >= (1 << 12) || address < -(1 << 12)) {
                                // SPIM flags as warning, I'll flag as error b/c RARS text segment not long
                                // enough for it to be OK.
                                errors.add(ErrorMessage.error(
                                    this.sourceProgram,
                                    this.sourceLine,
                                    0,
                                    "Branch target word address beyond 12-bit range"
                                ));
                                return;
                            }
                            absoluteAddress = false;
                        } else if (format == BasicInstructionFormat.J_FORMAT) {
                            address -= this.textAddress;
                            if (address >= (1 << 20) || address < -(1 << 20)) {
                                errors.add(ErrorMessage.error(
                                    this.sourceProgram,
                                    this.sourceLine,
                                    0,
                                    "Jump target word address beyond 20-bit range"
                                ));
                                return;
                            }
                            absoluteAddress = false;
                        }
                    }
                    basicInstructionBuilder.append(address);
                    if (absoluteAddress) { // record as address if absolute, second if relative
                        this.basicStatementList.addAddress(address);
                    } else {
                        this.basicStatementList.addValue(address);
                    }
                    this.operands.add(address);
                }
                case INTEGER_5, INTEGER_6, INTEGER_12, INTEGER_12U, INTEGER_20, INTEGER_32 -> {

                    final int tempNumeric = BinaryUtils.stringToInt(tokenValue);

                    /* **************************************************************************
                     * MODIFICATION AND COMMENT, DPS 3-July-2008
                     *
                     * The modifications of January 2005 documented below are being rescinded.
                     * All hexadecimal immediate values are considered 32 bits in length and
                     * their classification as INTEGER_5, INTEGER_16, INTEGER_16U (new)
                     * or INTEGER_32 depends on their 32 bit second. So 0xFFFF will be
                     * equivalent to 0x0000FFFF instead of 0xFFFFFFFF. This change, along with
                     * the introduction of INTEGER_16U (adopted from Greg Gibeling of Berkeley),
                     * required extensive changes to instruction templates especially for
                     * usePseudoInstructions-instructions.
                     *
                     * This modification also appears inbuildBasicStatementFromBasicInstruction()
                     * in rars.ProgramStatement.
                     *
                     * ///// Begin modification 1/4/05 KENV
                     * ///////////////////////////////////////////
                     * // We have decided to interpret non-signed (no + or -) 16-bit hexadecimal
                     * immediate
                     * // operands as signed values in the range -32768 to 32767. So 0xffff will
                     * represent
                     * // -1, not 65535 (bit 15 as sign bit), 0x8000 will represent -32768 not
                     * 32768.
                     * // NOTE: 32-bit hexadecimal immediate operands whose values fall into this
                     * range
                     * // will be likewise affected, but they are used only in usePseudoInstructions-instructions.
                     * The
                     * // code in ExtendedInstruction.java to split this number into upper 16 bits
                     * for "lui"
                     * // and lower 16 bits for "ori" works with the original source code token, so
                     * it is
                     * // not affected by this tweak. 32-bit immediates in data segment directives
                     * // are also processed elsewhere so are not affected either.
                     * ////////////////////////////////////////////////////////////////////////////////
                     *
                     * if (tokenType != TokenTypes.INTEGER_16U) { // part of the Berkeley mod...
                     * if ( Binary.isHex(tokenValue) &&
                     * (tempNumeric >= 32768) &&
                     * (tempNumeric <= 65535) ) // Range 0x8000 ... 0xffff
                     * {
                     * // Subtract the 0xffff bias, because strings in the
                     * // range "0x8000" ... "0xffff" are used to represent
                     * // 16-bit negative numbers, not positive numbers.
                     * tempNumeric = tempNumeric - 65536;
                     * // Note: no action needed for range 0xffff8000 ... 0xffffffff
                     * }
                     * }
                     ************************** END DPS 3-July-2008 COMMENTS
                     *******************************/

                    basicInstructionBuilder.append(tempNumeric);
                    if (tokenType == TokenType.INTEGER_5) {
                        this.basicStatementList.addShortValue(tempNumeric);
                    } else {
                        this.basicStatementList.addValue(tempNumeric);
                    }
                    this.operands.add(tempNumeric);
                }
                ///// End modification 1/7/05 KENV ///////////////////////////////////////////
                default -> {
                    basicStatementElement = tokenValue;
                    basicInstructionBuilder.append(basicStatementElement);
                    this.basicStatementList.addString(basicStatementElement);
                }
            }
            // add separator if not at end of token list AND neither current nor
            // next token is a parenthesis
            if ((i < this.strippedTokenList.size() - 1)) {
                final var nextTokenType = this.strippedTokenList.get(i + 1).getType();
                if (tokenType != TokenType.LEFT_PAREN
                    && tokenType != TokenType.RIGHT_PAREN
                    && nextTokenType != TokenType.LEFT_PAREN
                    && nextTokenType != TokenType.RIGHT_PAREN
                ) {
                    basicInstructionBuilder.append(",");
                    this.basicStatementList.addString(",");
                }
            }
        }
        this.basicAssemblyStatement = basicInstructionBuilder.toString();
    } // buildBasicStatementFromBasicInstruction()

    /**
     * Given the current statement in Basic Assembly format (see above), build the
     * 32-bit binary machine code statement.
     *
     * @param errors
     *     The list of assembly errors encountered so far. May add to it
     *     here.
     */
    public void buildMachineStatementFromBasicStatement(final @NotNull ErrorList errors) {
        switch (this.instruction) {
            case final ExtendedInstruction ignored -> {
                // This means the pseudo-instruction expansion generated another
                // pseudo-instruction (expansion must be to all basic instructions).
                // This is an error on the part of the pseudo-instruction author.
                errors.add(ErrorMessage.error(
                    this.sourceProgram,
                    this.sourceLine,
                    0,
                    "INTERNAL ERROR: usePseudoInstructions-instruction expansion contained a " +
                        "pseudo-instruction"
                ));
            }
            case final BasicInstruction basic -> {
                // mask indicates bit positions for 'f'irst, 's'econd, 't'hird operand
                this.machineStatement = basic.getOperationMask();
                final BasicInstructionFormat format = basic.getInstructionFormat();

                if (format == BasicInstructionFormat.J_FORMAT) {
                    this.insertBinaryCode(
                        this.operands.get(0),
                        Instruction.operandMask[0],
                        errors
                    );
                    this.insertBinaryCode(
                        toJumpImmediate(this.operands.get(1)),
                        Instruction.operandMask[1],
                        errors
                    );
                } else if (format == BasicInstructionFormat.B_FORMAT) {
                    this.insertBinaryCode(
                        this.operands.get(0),
                        Instruction.operandMask[0],
                        errors
                    );
                    this.insertBinaryCode(
                        this.operands.get(1),
                        Instruction.operandMask[1],
                        errors
                    );
                    this.insertBinaryCode(
                        toBranchImmediate(this.operands.get(2)),
                        Instruction.operandMask[2],
                        errors
                    );
                } else { // Everything else is normal
                    for (int i = 0; i < this.operands.size(); i++) {
                        this.insertBinaryCode(
                            this.operands.get(i),
                            Instruction.operandMask[i],
                            errors
                        );
                    }
                }
                this.binaryStatement = BinaryUtils.binaryStringToInt(this.machineStatement);
            }
            case final CompressedInstruction compressed -> {
                // TODO
                // mask indicates bit positions for 'f'irst, 's'econd, 't'hird operand
//                this.machineStatement = compressed.getOperationMask();
//                final var format = compressed.getInstructionFormat();

//                if (format == BasicInstructionFormat.J_FORMAT) {
//                    this.insertBinaryCode(this.operands[0], Instruction.operandMask[0], errors);
//                    this.insertBinaryCode(ProgramStatement.toJumpImmediate(this.operands[1]),
//                            Instruction.operandMask[1],
//                            errors);
//                } else if (format == BasicInstructionFormat.B_FORMAT) {
//                    this.insertBinaryCode(this.operands[0], Instruction.operandMask[0], errors);
//                    this.insertBinaryCode(this.operands[1], Instruction.operandMask[1], errors);
//                    this.insertBinaryCode(ProgramStatement.toBranchImmediate(this.operands[2]),
//                            Instruction.operandMask[2],
//                            errors);
//                } else { // Everything else is normal
//                    for (int i = 0; i < this.numOperands; i++)
//                        this.insertBinaryCode(this.operands[i], Instruction.operandMask[i], errors);
//                }
//                this.binaryStatement = Binary.binaryStringToInt(this.machineStatement);
            }
            case null -> throw new IllegalStateException("Instruction is null");
        }
    }

    /**
     * Crude attempt at building String representation of this complex structure.
     *
     * @return A String representing the ProgramStatement.
     */
    @Override
    public @NotNull String toString() {
        final var builder = new StringBuilder();
        final var textAddressString = "[%s]".formatted(BinaryUtils.intToHexString(this.textAddress));
        builder.append(textAddressString);
        if (this.basicAssemblyStatement != null) {
            final var firstSpaceIndex = this.basicAssemblyStatement.indexOf(" ");
            final var instruction = this.basicAssemblyStatement.substring(0, firstSpaceIndex);
            final var operands = this.basicAssemblyStatement.substring(firstSpaceIndex + 1);
            builder.append(" %-7s %-21s".formatted(instruction, operands));
        } else {
            builder.append(this.getPrintableBasicAssemblyStatement());
        }
        if (this.machineStatement != null) {
            final var machineStatementString = "| %s | %s|%s|%s|%s".formatted(
                BinaryUtils.binaryStringToHexString(this.machineStatement),
                this.machineStatement.substring(0, 8),
                this.machineStatement.substring(8, 16),
                this.machineStatement.substring(16, 24),
                this.machineStatement.substring(24, 32)
            );
            builder.append(machineStatementString);
        }
        return builder.toString();
    } // toString()

    /**
     * Produces RISCVprogram object representing the source file containing this
     * statement.
     *
     * @return The RISCVprogram object. May be null...
     */
    public @Nullable RISCVProgram getSourceProgram() {
        return this.sourceProgram;
    }

    /**
     * Produces String name of the source file containing this statement.
     *
     * @return The file name.
     */
    public @Nullable File getSourceFile() {
        return (this.sourceProgram == null) ? null : this.sourceProgram.getFile();
    }

    /**
     * Produces RISCV source statement.
     *
     * @return The RISCV source statement.
     */
    public @NotNull String getSource() {
        return this.source;
    }

    /**
     * Produces line number of RISCV source statement.
     *
     * @return The RISCV source statement line number.
     */
    public int getSourceLine() {
        return this.sourceLine;
    }

    /**
     * Produces Basic Assembly statement for this RISCV source statement.
     * All numeric values are in decimal.
     *
     * @return The Basic Assembly statement.
     */
    public String getBasicAssemblyStatement() {
        return this.basicAssemblyStatement;
    }

    /**
     * Produces printable Basic Assembly statement for this RISCV source
     * statement. This is generated dynamically and any addresses and
     * values will be rendered in hex or decimal depending on the current
     * setting.
     *
     * @return The Basic Assembly statement.
     */
    public @NotNull String getPrintableBasicAssemblyStatement() {
        return this.basicStatementList.toString();
    }

    /**
     * Produces 32-bit binary machine statement as int.
     *
     * @return The int version of 32-bit binary machine code.
     */
    public int getBinaryStatement() {
        return this.binaryStatement;
    }

    /**
     * Produces token list generated from original source statement.
     *
     * @return The TokenList of Token objects generated from original source.
     */
    public @Nullable TokenList getOriginalTokenList() {
        return this.originalTokenList;
    }

    /**
     * Produces Instruction object corresponding to this statement's operator.
     *
     * @return The Instruction that matches the operator used in this statement.
     */
    public @Nullable Instruction getInstruction() {
        return this.instruction;
    }

    /**
     * Produces Text Segment address where the binary machine statement is stored.
     *
     * @return address in Text Segment of this binary machine statement.
     */
    public int getAddress() {
        return this.textAddress;
    }

    /**
     * Returns true if the statement contains an operand of the given index.
     */
    public boolean hasOperand(final int index) {
        return index > 0 && index < this.operands.size();
    }

    /**
     * Produces operand second from given array position (first operand is position
     * 0).
     *
     * @param i
     *     Operand position in array (first operand is position 0).
     * @return Operand second at given operand array position.
     * @throws IndexOutOfBoundsException
     *     if illegal operand position.
     */
    public int getOperand(final int i) throws IndexOutOfBoundsException {
        return this.operands.get(i);
    }

    /**
     * Given operand (register or integer) and mask character ('f', 's', or 't'),
     * generate the correct sequence of bits and replace the mask with them.
     *
     * @param value
     *     the second to be masked in (will be converted to binary)
     * @param mask
     *     the second (f,s, or t) to mask out
     * @param errors
     *     error list to append errors to in the event of unrecoverable
     *     errors
     */
    private void insertBinaryCode(final int value, final char mask, final ErrorList errors) {
        final var stateBuilder = new StringBuilder(this.machineStatement);

        // Just counts the number of occurrences of the mask in machineStatement.
        // This could be done with a method from StringUtils, but I didn't think
        // bringing in another dependency was worth it.
        int length = 0;
        for (int i = 0; i < stateBuilder.length(); i++) {
            if (stateBuilder.charAt(i) == mask) {
                length++;
            }
        }

        // should NEVER occur
        // if it does, then one of the BasicInstructions is malformed
        if (length == 0) {
            errors.add(ErrorMessage.error(
                this.sourceProgram,
                this.sourceLine,
                0,
                "INTERNAL ERROR: mismatch in number of operands in statement vs mask"
            ));
            return;
        }

        // Replace the mask bit for bit with the binary version of the second
        // The old version of this function assumed that the mask was continuous
        final String bitString = BinaryUtils.intToBinaryString(
            value,
            length
        );
        int valueIndex = 0;
        for (int i = 0; i < stateBuilder.length(); i++) {
            if (stateBuilder.charAt(i) == mask) {
                stateBuilder.setCharAt(
                    i,
                    bitString.charAt(valueIndex)
                );
                valueIndex++;
            }
        }

        this.machineStatement = stateBuilder.toString();
    }

    /**
     * Structure for getting the dimensions to be used when
     * generating the string representation of the statement.
     */
    private record StringDimensions(
        int textAddressesWidth,
        int instructionsWidth,
        int operandsWidth
    ) {
    }

    /**
     * Little class to represent basic statement as list
     * of elements. Each element is either a string, an
     * address or a second. The toString() method will
     * return a string representation of the basic statement
     * in which any addresses or values are rendered in the
     * current number format (e.g. decimal or hex).
     * NOTE: Address operands on Branch instructions are
     * considered values instead of addresses because they
     * are relative to the PC.
     * DPS 29-July-2010
     */
    private static final class BasicStatementList {

        private final ArrayList<ListElement> list;

        BasicStatementList() {
            this.list = new ArrayList<>();
        }

        void addString(final String string) {
            this.list.add(new ListElement(
                0,
                string,
                0
            ));
        }

        void addAddress(final int address) {
            this.list.add(new ListElement(
                1,
                null,
                address
            ));
        }

        void addValue(final int value) {
            this.list.add(new ListElement(
                2,
                null,
                value
            ));
        }

        void addShortValue(final int value) {
            this.list.add(new ListElement(
                3,
                null,
                value
            ));
        }

        @Override
        public String toString() {
            final int addressBase =
                (BOOL_SETTINGS.getSetting(BoolSetting.DISPLAY_ADDRESSES_IN_HEX))
                    ? NumberDisplayBaseChooser.HEXADECIMAL
                    : NumberDisplayBaseChooser.DECIMAL;
            final int valueBase = (BOOL_SETTINGS.getSetting(BoolSetting.DISPLAY_VALUES_IN_HEX))
                ? NumberDisplayBaseChooser.HEXADECIMAL
                : NumberDisplayBaseChooser.DECIMAL;

            final StringBuilder result = new StringBuilder();
            for (final ListElement e : this.list) {
                switch (e.type) {
                    case 0:
                        result.append(e.sValue);
                        break;
                    case 1:
                        result.append(NumberDisplayBaseChooser.formatNumber(
                            e.iValue,
                            addressBase
                        ));
                        break;
                    case 2:
                        if (valueBase == NumberDisplayBaseChooser.HEXADECIMAL) {
                            result.append(BinaryUtils.intToHexString(e.iValue)); // 13-July-2011,
                            // was:
                            // intToHalfHexString()
                        } else {
                            result.append(NumberDisplayBaseChooser.formatNumber(
                                e.iValue,
                                valueBase
                            ));
                        }
                        break;
                    case 3:
                        result.append(e.iValue);
                        break;
                    default:
                        break;
                }
            }
            return result.toString();
        }

        private record ListElement(int type, String sValue, int iValue) {
        }
    }

}
